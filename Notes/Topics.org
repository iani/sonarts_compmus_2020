# 27 Nov 2020 12:05 Some topics to write more about

* Infrastructure
** Variables
*** kinds of variables: local, global, environment, interpreter, instance, class
**** local variables
**** global variables
**** environment variables
**** instance variables
**** class variables
**** special variables
***** this
***** thisFunction
***** thisMethod
***** thisProcess
***** currentEnvironment
***** super
***** pi
** Collections
*** Basic types of collections: Array, Dictionary, Set
*** Important variants: List, Event
*** Sets vs. Bags
*** Exotic variants: LinkedList, Interval, MultiLevelIdentityDictionary
*** The Library class
*** Building collections
**** Arrays and ArrayedCollections
***** the (start ... end) shortcut
***** Building arrays with =rand= and =fill=.
***** Building arrays with =do=, =collect=, =select=
**** Building Dictionaries
**** Building Events (=make=).
*** Accessing collections
**** Accessing ArrayedCollections by index
**** Range indexes
**** Accessing by keys.  Identity vs Equality
**** Accessing by test. Sets.
*** Modifying the contents of collections
*** Changing the dimensionality and structure of collections
**** flop, flat, bubble, curdle
**** Specialized structure manipulations: reverse, rotate, stutter, mirror, pyramid
**** J-aspects in SuperCollider
** Conditional Structures
*** if, case, switch.
*** Shortcuts for conditionals testing for nil: ?, ??, !?

** Iteration

*** do, collect, select, reject, detect, while, loop

*** List comprehensions

*** inf as count limit argument in a loop. Danger: use wait to avoid freeze


** The Interpreter
*** String:interpret vs. String:compile
*** Interpreter variables
*** How the interpreter is used during sclang runtime
** What is =this=?
*** =this= is the interpreter when in code evaluated by the user directly
*** =this= is the current object when run in a method compiled in code of a Class


** Init, Startup, ServerBoot actions
** Closures
** Current environment
*** pushing the current environment
*** current environment inside closures (!)
** Events in depth
*** Event:use / Event:make
*** Event prototypes
*** Parent event
*** Event key/values behaving as methods

When a Function is stored in an Event under a key, one can use message-sending syntax to evaluate that Function. 

** Patterns

** The dependency mechanism
*** Raison d'Ãªtre. Similarity to private methods
*** Problems: Chosing action
*** Reasons for using Notification vs. Drawback of many objects involved
*** Alternative implementations: Notification vs. NotificationCentre

 Aspects to compare:
 Performance, functionality, interface.

** Clocks, defer, sched
** Using the AppClock in GUIs
** Routines
** Tasks
** How Pbind works
*** what is embedInStream? How does it work
**** getting the next value from each key-value pair
**** embedding each stream's value
** EventPattern as alternative to Pbind
** Introspection and its uses
*** For learning and understanding code
*** Inside programs
** Symbols vs. Strings
** Copying and in-place modification of objects

=reverse= modifies a Signal in-place ...
=add= may 

** Hash
** Primitives
** The structure of the Class Hierarchy Tree
*** Meta- Classes (Classes of Classes)

Note: Compare to structure of the Class Hierarchy in SmallTalk.

* Music and Audio
** Understanding frequency in musical intervals
*** Logarithmic nature of interval perception
**** In intervals, we do not subtract frequences. Instead, we divide them.
***** Compare the same intervals in different frequency ranges
**** Possibly this is related to the fact that in sine signals, to change the frequency, one multiples the arithmetic series that generates the signal.
*** Using plot to understand linear vs. logarithmic curves
*** Using Line and XLine to understand the logarithmic perception of pitch
Notes: 
**** To hear the difference clearly between Line/Xline, Falling line is better than rising line 
**** Perhaps use Sample-and-Hold to convert line to steps for clarity
**** Also use Demand with arrays (arithmetic vs. geometric series) to demonstrate non-linearity of pitch perception
** Understanding Sin, sin/cos, phase and symmetry in signals

Use plot to demonstrate how sine is calculated from an arithmetic sequence of numbers (in an Array).
Aspects to show:
*** Normalize
*** Calculate sine by sending a single message to an array
*** Plot the signal to see it
*** Shift phase by rotating an array of numbers 
*** Change frequency by scaling the signal (with multiply!)
***  Signal cancellation through phase difference
** Patterns
*** Patterns-Streams-Events basics
*** Pbind playing mechanism
*** Pbind examples, main features and variants

Instrument, degree, duration, chords, arpeggio, legato.
Ppar, Pmono, etc.

*** Scales, Tunings and Transposition in Patterns
*** Quant and synchronization
*** Regular Pattern Stream Generators
*** Filter Patterns
*** Advanced Pattern Manipulation Tools: Pkey etc.
*** Pbind, and its limits
*** Playing Pbind and its zoo of quasi add-ons in Event
(are all of them necessary?)
*** Some exotic pattern types/topics: Fdef, LazyEnvir, Plazy, PlazyEnvir ...
*** Modifying Patterns while they are playing (in an EventStream)
**** The EventPattern Class
** Demand UGens
** Some enigmatic UGens (for non Audio-Engineers)

Gate, Latch (Sample and Hold), Amplitude, Changed, Integrate, PulseCount, Stepper, Summer, WrapSummer

How to calculate the duration of a condition being true?

Comparing sigals.

Select.
** Control inputs in SynthDefs and Synth Functions.

Arguments vs. \symbol.kr.

** Feedback 
** Envelopes
*** envelope shapes and shortcuts
*** envelopes with release node
*** envelopes with loops
*** changing envelope shapes on the fly
*** emulating envelopes with Demand ugens (And Line?)
*** Can one use buffers with Demand to store huge envelope shapes?
** Triggering Envelopes
*** Release vs. free. 

Show the practical/musical difference of release vs. free.

*** Triggering release with gate.
Why this is necessary for playing patterns.

Retriggering vs. single-pass envelopes, distinguished with =doneAction=.

 Problems in triggering from sclang due to latency and time limits in signal response.  Instead, trigger a single change in a signal, and track that change with =Changed.kr=. 

** Demand UGens and =Duty=
** Triggering events from (control) signals
** All that async headache
*** Waiting for Server to boot
*** Waiting for SynthDefs and Buffers to load
*** Waiting for Synths to start or end
*** Tracking state of Synths
** Things one can do with PlayBuf and BufRd
** Reading Buffers from file. Getting Buffer info
*** Alex McLeans' buffer reading trick from SuperDirt

Important for reading large numbers of files!

** Buffer Granulation
*** Triggering grains
** Linking Synths
*** Synth Order
*** Creating and managing Groups in order
*** Managing i/o bus connections
*** Many-to-one and One-to many synth link configurations

* Questions and Notes made during teaching

** What is the use of Signal?

The Signal is not an OutputProxy. It is also not a Buffer.  It holds data in sclang that when sent to scsynth can become a Buffer.

** Can we make aliases so that changes in a parameter are reflected in many things?

* Exercises

** Arrays

*** Array creation
**** [\a, \b, \c]
**** Array.newClear
**** Array.fill
**** Array.rand
**** (1..10)
**** (1, 1.5 .. 10)
**** Array.series
**** Array.geom
**** Array.fib
**** Array.rand
**** Array.rand2
**** Array.linrand
**** Array.exprand
**** Array.interpolation

*** Accessing Array elements

**** [1, 2, 3][1]
**** (1..10)[5..]
**** (1..10)[..2]
**** =(1..10)[[1,3]]=
**** (1..10)@0
**** (1..10)@12
**** (1..10)@@12
**** (1..10).at(0)
**** (1..10).at(20)
**** (1..10).clipAt(20)
**** (1..10).wrapAt(20)
**** (1..10).foldAt(20)
**** (1..10).first;
**** (1..10).last;
**** [3, 4, 5]@|@[6, 8]
**** [3, 4, 5]|@|6
*** Searching in Arrays
**** indexOf
**** indicesOf
**** indexOfEqual
**** indicesOfEqual
**** includes
*** Replacing Array elements
**** (1..10).put(3, \x);
**** =(1..10)[[1,3]] = [\x, \y];=
*** Iterating over Arrays
**** (40..50) do: { ... }
**** (40..50) collect: { ... }
**** (40..50) select: { ... }
**** (40..50) reject: { ... }
*** Manipulating array structure

*** Numeric operations and applications of Arrays

** Control structures

*** if () { } { }
*** while
*** loop
*** case
*** switch
*** ?
*** !?
** Returning results
*** ^
** Synth Parameter Control
** Freeing and Releasing Synths
*** 
** Envelopes
*** Creating Envelopes
*** Triggering Envelopes
*** Releasing Envelopes

** Signals

** Buffers

** Mouse control

** Gui control

** Buses and Synth IO
** Synth Order
** Routines
** Patterns + Streams
** Events
** Closures

what is the value of this in the following cases: ... 
** Scales
** Demand UGens
** Duty and TDuty
** linear and exponential range use and conversion
** Line
** ControlSpecs
* Background - Context - Meta

** From human code to machine code

** Syntax and Semantics

** Naming things. All that identifier business

Why we need namespaces ... and the sc versions of that. Closures vs Environments.

Particularities: The context of closures and environments in threads.  The uses and trappings of that.

** Recursion

** Symmetry

** Randomness vs. Chaos

** Measuring perception sense, sensing, meaning

** Signal, Information, Medium, Communication, Code

** Sine, cosine, frequency - and a possible connection to logarithmic perception of pitch

* Things that need radical cleaning (or in some cases even _TRASHING_) in SCClassLibrary
** NotificationCenter (Certainly)
** AbstractResponderFunc (Very probably)
** Server and its helper funcs such as ServerWatcher (Painful, but must)
** Default Event - Event Prototype (Perhaps, perhaps, but would be nice)

Very complex. Would need a deep study before any improvements can be suggested.
However, it seems that things should and can be simpler.

