
* Beginner

** variables
*** start a sound and stop it
*** start a sound and stop it with a decay (fade out time) of 5 seconds
*** start 2 sounds and stop the first one without stopping the second one

*** Find and correct the error here

a = 1;
beta = a.sqrt;
a + beta;

** SynthDefs

** Envelopes

** Arrays

** Patterns 

* Intermediate

** "=mpairs=": given an array of n elements, create an array that pairs each element of the array with the element of the same array in reverse order. 

*** problem
 For example: Let us call the method that does the operation =mpairs=.
 Then =[ 'a', 'b', 'c', 'd' ].mpairs= should return: 

#+begin_src sclang
 [ [ 'a', 'd' ], [ 'b', 'c' ], [ 'c', 'b' ], [ 'd', 'a' ] ]
#+end_src

*** solution
**** As Function
#+begin_src sclang
//: 1: define the function
~mirror2 = { | list |
     list.mirror2.clump(list.size).flop;
};
//: 2: test the function
~mirror2.((1..4));
// Returns: [ [ 1, 4 ], [ 2, 3 ], [ 3, 2 ], [ 4, 1 ] ]
~mirror2.((1..5));
// Returns: [ [ 1, 5 ], [ 2, 4 ], [ 3, 3 ], [ 4, 2 ], [ 5, 1 ] ]
#+end_src
**** As Method
#+begin_src sclang
+ SequenceableCollection {
     mpairs {
          ^this.mirror2.clump(this.size).flop;
     }
}
#+end_src

** start 89 sounds, then stop the 2nd, 3d, 5th, 8th, 13th, 21st, 34th, 55th sound at once, all together.

More difficult variant: Devise an algorithmic way for selecting the 2nd, 3d, 5th, 8th, 13th, 21st, 34th, 55th synth, without typing those numbers in the code.

** create a function that counts to infinity, starting from 5.
** create a function that produces the fibonacci numbers
** create a function or method =recurse= for recursing over all elements of a tree
*** Specification / Parts of the function:

 1. a function/method to perform if the node of the tree is a tree (or collection?)
 2. a function/method to perform if the node of the tree is a leaf
 3. a function to perform on a tree to return its immediate subtree branches
*** Implementation hint: Use =respondsTo:=
    :PROPERTIES:
    :DATE:     <2020-12-12 Sat 02:57>
    :END:

Hint: You can use the message =respondsTo:= to determine whether the receiver can iterate.

Further problem: Some types of objects may need a different message to produce their list of branches. Should this be given as method name (Symbol), or as a function in an additional argument "=iterator=" (point 3 above)?

For example, if applying =recurse= over a Class to recurse on its subclass tree, the =iterator= message should be =subclasses=. 

Draft: 

#+begin_src sclang
f = { | receiver, ifBranch, ifFleaf /*, iterator = \do */ |
    if (receiver respondsTo: \do) { // alternatively to \do: iterator
        ifBranch.(receiver);
    }{
        ifLeaf.(receiver);
        // alternatively: (receiver.perform(iterator) do: ... )
        receiver do: { | branch |
            f.(branch, ifBrach, ifFleaf /*, iterator */);
        }
    }
};
#+end_src

** Design a synth algorithm using additive synthesis that produces a pulse wave 
** Design a synth algorithm using additive synthesis that produces a saw wave 
** Program the jumping pattern from Intro to Carnatic Music
   :PROPERTIES:
   :DATE:     <2020-12-11 Fri 15:03>
   :END:

Hint: Use + operation to combine a Pseq with a nested pattern.

** Write a class that performs arithmetic on rational numbers

Define a binary operator for producing a rational integer from a numerator and a denominator.

A rational numbers should print as: (numerator/denominator). For example: (2/3)

Rational numbers should automatically simplify to smallest numerator/denominator.

Implement all operations described in:
https://en.wikipedia.org/wiki/Rational_number
(Note: as operators)

Further references:

https://mitpress.mit.edu/sites/default/files/sicp/full-text/sicp/book/node28.html
http://www.blackwasp.co.uk/RationalNumberArithmetic.aspx

** Combine patterns in 2 different ways: (a) nesting. (b) binary operators
   :PROPERTIES:
   :DATE:     <2020-12-14 Mon 15:03>
   :END:


* Advanced

** Polyrhythms, Konnakol 
*** Program polyrhythms using demand UGens.  Can you change the number of beats in a cycle while playing?
*** Program the 75/16 Tatighinathom pattern from the Extreme Math Nerd Music Youtube video
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 14:30>
    :END:

 https://www.youtube.com/watch?v=-mS06lEmY3s

*** Program the Twinkle Twinkle Little Star pattern by Manjunath - with sample cutting
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 14:41>
    :END:

 OFF BEAT TWINKLE TWINKLE LITTLE STAR
 https://www.youtube.com/watch?v=6aHWJKJe9mU


** Indian Music Theory - Vocal ornaments + Pattern combinations
*** Devise a way to play Tisram and Gati in patterns - in a single melody
*** Devise a way to play Gamakas in patterns
*** Devise a way to play Brighas in  patterns
*** Devise a way to play polyrhythmic tisram in patterns - in parallel, synchronized sharing a basic beat
** Greek and Near Eastern Music Theory - Tunings - Scales
*** Program Turkish tunings based on (Mercator/Holder) 53-division of the octave

See;
 Holdrian Comma 
https://en.wikipedia.org/wiki/Holdrian_comma
https://en.wikipedia.org/wiki/53_equal_temperament
https://en.wikipedia.org/wiki/Nicholas_Mercator


*** Program Greek tunings based on the (Karas/Epitropi) 72 division of the octave
*** Program Greek tunings based on the (Chrysanthos) 68 division of the octave 
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:50>
    :END:

http://www.pandoura.gr/armoniko-egxeiridio/ti-den-mas-eipan-gia-to-xrisantho

*** Program the helikon and kanon from the Αρμονικά of Κλαύδιος Πτολεμαίος
    :PROPERTIES:
    :DATE:     <2020-12-11 Fri 14:55>
    :END:
** Western Music Theory
*** Program Messiaen's Modes of Limited Transposition
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 14:59>
    :END:

https://www.youtube.com/watch?v=nCXxV7eDEPc
*** Program Messiaen's Mode de valeurs et d'intensités
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:01>
    :END:

https://messiaenandmath.tumblr.com/modedevaleurs

https://en.wikipedia.org/wiki/Quatre_%C3%89tudes_de_rythme

https://www.youtube.com/watch?v=tippo8S5YlI

https://www.youtube.com/watch?v=S3xEnDpM1mU

Messiaen: Quatre Études de Rythme, with score - II. Mode de valeurs et d'intensités
*** Program A. Forte's Pitch Class Sets
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 15:07>
    :END:
*** Program A. Schoenberg's (equal tempered) tone net
*** 
*** Program Schillinger's rhythmic + melodic patterns

** New types of Patterns
*** Define a method or class for playing a =Pseq= as a sequence of pairs generated with the =mpairs= method defined above under [[Intermediate]] exercises. 
    :PROPERTIES:
    :DATE:     <2020-12-12 Sat 03:13>
    :END:

*** Which other patterns besides =Pseq= can work with =mpairs=?
    :PROPERTIES:
    :DATE:     <2020-12-12 Sat 03:14>
    :END:

*** Program a list pattern which gives access to the list data of the stream for on-the-fly modification
*** Program a way to share a data structure in multiple patterns playing in parallel.  
*** Program a way to select pitches or harmonic structures by solving optimization problems on the fly in a polyphonic pattern sharing a harmonic field data structure

 Hint: list comprehensions
*** Program feedback in patterns and compare to feedback in signals
    :PROPERTIES:
    :DATE:     <2020-12-14 Mon 11:37>
    :END:

* List of toopics to cover
** Variables

*** Interpreter Variables

 Store a synth in an interpreter variable, and free it.

 Store a synth in an interpreter variable, and release it, with a release duration of 7 seconds.

*** Environment Variables

*** Variables in closures

*** Variables in methods

*** Arguments as variables

*** Special Variables

 What is the value of =this= in the following code: 



 What is the value of =this= in the following code: 

** Arrays
*** Array creation
**** [\a, \b, \c]
**** Array.newClear
**** Array.fill
**** Array.rand
**** (1..10)
**** (1, 1.5 .. 10)
**** Array.series
**** Array.geom
**** Array.fib
**** Array.rand
**** Array.rand2
**** Array.linrand
**** Array.exprand
**** Array.interpolation

*** Accessing Array elements

**** [1, 2, 3][1]
**** (1..10)[5..]
**** (1..10)[..2]
**** =(1..10)[[1,3]]=
**** (1..10)@0
**** (1..10)@12
**** (1..10)@@12
**** (1..10).at(0)
**** (1..10).at(20)
**** (1..10).clipAt(20)
**** (1..10).wrapAt(20)
**** (1..10).foldAt(20)
**** (1..10).first;
**** (1..10).last;
**** [3, 4, 5]@|@[6, 8]
**** [3, 4, 5]|@|6
*** Searching in Arrays
**** indexOf
**** indicesOf
**** indexOfEqual
**** indicesOfEqual
**** includes
*** Replacing Array elements
**** (1..10).put(3, \x);
**** =(1..10)[[1,3]] = [\x, \y];=
*** Iterating over Arrays
**** (40..50) do: { ... }
**** (40..50) collect: { ... }
**** (40..50) select: { ... }
**** (40..50) reject: { ... }
*** Manipulating array structure
**** flop
**** flat
**** bubble
**** curdle
**** scramble
**** stutter
**** pyramid
**** j operations
*** Numeric operations and applications of Arrays
**** Adverbs for binary operators

** Control structures

*** if () { } { }
*** while
*** loop
*** case
*** switch
*** ?
*** !?
** List comprehensions
** Returning results
*** ^
** Synth Parameter Control
** Freeing and Releasing Synths
*** 
** Envelopes
*** Creating Envelopes
*** Triggering Envelopes
*** Releasing Envelopes

** Signals

** Buffers

*** Play a buffer reversed (back to front)

*** Play a buffer starting from the middle of the buffer

*** Buffer grains

** Mouse control

** Gui control
*** using defer in GUIs
** Buses and Synth IO
** Synth Order
** Routines
** Patterns + Streams
*** Sequential Patterns
*** Random Patterns
*** Combining Patterns
**** Arithmetic operations on Patterns
***** x adverb for binary operators on Streams
**** Nesting Patterns
**** Pn vs Pstutter
**** Filter Patterns

** Events
*** changing the instrument (synthdef used)
*** playing chords
*** synchronising
*** monophonic
*** legato
*** arpeggio
** Sched and Clocks
*** AppClock - TempoClock - SystemClock
** Closures

 what is the value of this in the following cases: ... 

 use a closure to count
** Scales and Tunings
*** midi - cents - midicps
** Demand UGens
** Duty and TDuty
** linear and exponential range use and conversion
** Line
** ControlSpecs
** UGens and Synthesis Techniques
*** Additive Synthesis
*** Subtractive Synthesis
**** Filter Ugens
*** Resonance
**** Ringz
**** Resonz
**** Klank
**** DynKlank,
**** Klang
*** Spectral Processing
*** Delays, Decays, Reverb
**** JPverb
**** JPverbRaw
**** GVerb
**** Delay
**** Decay
**** Comb
**** AllPass

*** Wavetable synthesis
*** Noise and Chaos UGens
**** Kinds of Noise: WhiteNoise
**** Kinds of LFNoise:
**** Chaos UGens

** Plotting signals + data
** Synthesizing signals (numerically/algorithmically)
** Multichannel expansion
** Multichannel output
*** Pan2, PanAz
*** Ambisonics
** File IO

